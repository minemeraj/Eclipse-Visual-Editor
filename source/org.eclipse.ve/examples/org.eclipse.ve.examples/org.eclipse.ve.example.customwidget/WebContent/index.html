<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Visual Editor Tutorial 1</title>
  <link rel="stylesheet" type="text/css" href="default_style.css">
</head>
<body>
<div align="right"> &nbsp;
<table border="0" cellpadding="2" cellspacing="0" width="100%">
  <tbody>
    <tr>
      <td colspan="2" align="left" bgcolor="#0080c0" valign="top"><b><font
 face="Arial,Helvetica"><font color="#ffffff">Eclipse Article</font></font></b></td>
    </tr>
  </tbody>
</table>
</div>
<div align="left">
<h1 title="RCP Tutorial"><img src="images/Idea.jpg" align="middle"
 height="86" width="120"></h1>
</div>
<h1 align="center"><font color="#0000ff">Extending The </font> <a
 href="http://www.eclipse.org/vep">Visual Editor</a><font
 color="#0000ff"><br>
Tutorial&nbsp; 1 - Enabling support for a custom widget<br>
</font></h1>
<h2>Background</h2>
<p class="summary">The Visual Editor project provides reference
implementations of a graphical user interface builder for the JFC and
SWT widget toolkits built around an extensible framework.&nbsp; The
motivation for this came from exerience with previous GUI builders that
while they provided high function end points for particular toolkits
were unable to be adapted to support custom behavior for areas of
functionality such as custom widgets, custom layout managers, user
specific code generation patterns, etc...&nbsp; A design goal of the
visual editor is that is none of its own custom behavior for any JFC or
SWT classes is done through any hard coding in the base, so any
specific logic that the VE employs to enable say a tab pane, dropping a
control on a composite, or showing feedback for a particular layout
manager is soft coded through extension points and can be leveraged by
anyone wishing to employ similar techniques.<br>
</p>
<p class="summary">This tutorial covers an example where a user has a
custom widget that they wish to extend the visual editor to have
specific builder behavior for.&nbsp; It covers topics such as extending
the Visual Editor's palette, building a BeanInfo class and working with
EMF .override files to introduce custom editor behavior.<br>
</p>
<p><b>Gili Mendel, IBM<br>
Joe Winchester, IBM<br>
Dave Orme, db4objects</b></p>
<p><font size="1">
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%B %d, %Y" startspan -->March
16, 2005<!--webbot bot="Timestamp" endspan i-checksum="17411" --></font></p>
<hr width="100%">
<h2><a name="Introduction"></a>Introduction</h2>
<p>In this tutorial a 3.1 based Eclipse plugin&nbsp; <i>
org.eclipse.ve.example.customwidget</i><b> </b>will be created that
illustrates some of the basic touch points of the visual editor.&nbsp;
To do this an SWT custom widget will be built that combines a Label,
Text and Button in a single widget called <span
 style="font-style: italic;">org.eclipse.ve.examples.customwidget.MyCustomPrompter</span>.&nbsp;
<br>
</p>
<p><img style="width: 243px; height: 34px;" alt="CustomWidget"
 src="images/CustomWidget.JPG"><br>
</p>
<p>MyCustomPrompter has two properties: <span
 style="font-style: italic;">type </span>and <span
 style="font-style: italic;">text</span>.&nbsp; These each have get and
set methods and can be used to configure the behavior of the button and
the label's text.&nbsp; There is also a <span
 style="font-style: italic;">ButtonSelectionEvent </span>event that is
raised when the prompter's button is pressed, and listeners can
register for this callback using <span style="font-style: italic;">addButtonSelectionListener(ButtonSelectionListener
aListener); </span><br>
</p>
<p>In the
absence of the plugin that this tutorial builds for the class <span
 style="font-style: italic;">MyCustomPrompter </span>it can be used by
a user
who drops it onto an SWT composite by adding a JAR (or folder)
containing the class to their Java project's build path and using
ChooseBean from the palette to select MyCustomPrompter and drop it onto
a composite and begin working with it.&nbsp; Through inheritance (<span
 style="font-style: italic;">MyCustomPrompter </span>extends <span
 style="font-style: italic;">org.eclipse.swt.widgets.Composite</span>)
the custom control will be rendered correctly, its properties will be
determined using JavaBeans<sup>TM</sup> reflection and available to
modify using the PropertiesViewer.&nbsp; The event will also be
determined automatically through introspection by the Visual Editor and
available to the user to add listeners to through the Add Event
dialog.&nbsp; This tutorial shows how the
developer of the plugin can enable specific visual editor behavior over
and above the default that is determined through inherited behavior and
provide a high level edit experience for users of the <span
 style="font-style: italic;">MyCustomPrompter </span>class.&nbsp; The
examples given are purely for illustrative purposes only and to
highlight some of the available ways to extend the behavior of the
Visual Editor, and it is expected that the reader of this tutorial will
use it to learn the extension mechanism and then apply this to their
own custom widget or Java class.&nbsp;<span
 style="color: rgb(204, 0, 0);"> &lt;&lt; Disclaimer here about fitness
of the sample code required &gt;&gt;</span><br>
</p>
<ul>
  <li>
    <h3>Palette</h3>
  </li>
  <ul>
    <li>The visual editor provides a palette of classes from which the
user can choose commonly used classes.&nbsp; The tutorial shows how to
create a new palette category containing the CustomWidget to allow it
to be brought to the user's selection and easily selected and dropped
without having to use <span style="font-style: italic;">ChooseBean </span>and
enter the class name</li>
  </ul>
</ul>
<table style="text-align: left; width: 50%;" border="1" cellspacing="2"
 cellpadding="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">Before<br>
      </td>
      <td style="vertical-align: top;">With plugin showing <span
 style="font-style: italic;">Custom </span>category with the <span
 style="font-style: italic;">MyCustomPrompter </span>class<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><img
 style="width: 147px; height: 226px;" alt="OrignalPalette"
 src="images/OrignalPalette.JPG"><br>
      </td>
      <td style="vertical-align: top;"><img
 style="width: 148px; height: 241px;" alt="NewPalette"
 src="images/NetPalette.JPG"><br>
      </td>
    </tr>
  </tbody>
</table>
<ul>
  <li>
    <h3>Property sheet</h3>
  </li>
  <ul>
    <li>There is an <span style="font-style: italic;">int </span>property
called <span style="font-style: italic;">type </span>that affects the
text shown on the CustomPrompter's button.&nbsp; This has a set of
restricted values corresponding to static constrants.&nbsp; For
example, 0 is the constant CustomPrompter.DOTS, 1 is
CustomPrompter.MORE and 2 is CustomPrompter.OPEN. Rather than have the
user have to remember this the
property sheet will be extended so that there is a drop down list of
available values, and the existing value is shown as its meaningful
name rather than its internal <span style="font-style: italic;">int </span>value.</li>
  </ul>
</ul>
<br>
<table style="text-align: left; width: 75%;" border="1" cellspacing="2"
 cellpadding="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">Before<br>
      </td>
      <td style="vertical-align: top;">With plugin<br>
      </td>
      <td style="vertical-align: top;">With plugin<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-style: italic;">type
      </span>property displayed with default <span
 style="font-style: italic;">int </span>editor<br>
      </td>
      <td style="vertical-align: top;"><span style="font-style: italic;">type
      </span>property displayed as static constant name</td>
      <td style="vertical-align: top;"><span style="font-style: italic;">type
      </span>property edited with drop down list of enumerated
allowable values<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><img
 style="border: 1px solid ; width: 236px; height: 37px;"
 alt="OriginalType"
 src="file:///C:/Eclipse_3_1_M5a/eclipse/workspaces/dev_03_09/org.eclipse.ve.example.customwidget/WebContent/images/OriginalTypeProperty.JPG"></td>
      <td style="vertical-align: top;"><img
 style="border: 1px solid ; width: 234px; height: 37px;"
 alt="TypePropertyLabelProvider"
 src="file:///C:/Eclipse_3_1_M5a/eclipse/workspaces/dev_03_09/org.eclipse.ve.example.customwidget/WebContent/images/TypePropertyLabelProvider.JPG"></td>
      <td style="vertical-align: top;"><img
 style="border: 1px solid ; width: 228px; height: 70px;"
 alt="TypePropertyCellEditor"
 src="file:///C:/Eclipse_3_1_M5a/eclipse/workspaces/dev_03_09/org.eclipse.ve.example.customwidget/WebContent/images/TypePropertyCellEditor.JPG"></td>
    </tr>
  </tbody>
</table>
<ul>
  <ul>
    <li><span style="font-style: italic;">MyCustomPrompter </span>has
a <span style="font-style: italic;">String </span>property
called <span style="font-style: italic;">text </span>that reflects
the
value shown on the CustomPrompter's text widget.&nbsp; The default
property
sheet editor for a String property is a Text field that allows the
value to be changed, however the tutorial illustrates how to have a
custom property editor that launches a separate dialog through which
the value can be changed</li>
  </ul>
</ul>
<br>
<table style="text-align: left; width: 50%;" border="1" cellspacing="2"
 cellpadding="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">Before with default String
editor behavior for <span style="font-style: italic;">text </span>property<br>
      </td>
      <td style="vertical-align: top;">With plugin showing custom
editor for <span style="font-style: italic;">text </span>property<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><img
 style="border: 1px solid ; width: 232px; height: 37px;"
 alt="OriginalTextProperty" src="images/OriginalTextProperty.JPG"><br>
      </td>
      <td style="vertical-align: top;"><img
 style="border: 1px solid ; width: 233px; height: 37px;"
 alt="TextPropertyCellEditor" src="images/TextPropertyCellEditor.JPG"><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<ul>
  <li>
    <h3>Graphical behavior</h3>
  </li>
  <ul>
    <li>The visual editor uses the graphical editor framework or GEF to
render the visual classes to the user.&nbsp; GEF is a powerful
framework which uses EditPart classes as mediators between the
underlying model and the draw2d view layer.&nbsp; This is similar to
the controller in an MVC pattern and described in overview at <a
 href="http://www-128.ibm.com/developerworks/opensource/library/os-gef/index.html">Create
an
Eclipse based application using GEF.</a> The default behavior for a
visual class is a WYSIWYG rendering where a preview of the live runtime
widget is drawn.&nbsp; There are times when you may wish to override
this for a specific component such as to visually annotate the feedback
for the figure such as drawing grid lines, additional handles or other
features provided by GEF.&nbsp; As an example of how to alter the edit
part used by the visual editor the tutorial shows how to have <span
 style="font-style: italic;">MyCustomPrompter&nbsp; </span>rendered
with an ico.&nbsp; n&nbsp;<img style="width: 16px; height: 16px;"
 alt="Custom"
 src="file:///C:/Eclipse_3_1_M5a/eclipse/workspaces/dev_03_09/org.eclipse.ve.example.customwidget/WebContent/images/custom.gif">
and the text <span style="color: rgb(255, 0, 0);">VE Rules</span><span
 style="font-style: italic;"> </span>over the image of the live visual
control.&nbsp; In addition the default behavior of a Composite
graphical edit part is to draw a border around it in the editor so that
it can be located by the user irrespective of whether it has child
controls or not.&nbsp; <span style="font-style: italic;">MyCustomPrompter
      </span>is an aggregate of three child controls into a custom
widget so the graphical edit part will remove the artificial border.<br>
    </li>
  </ul>
</ul>
&nbsp;&nbsp;&nbsp; <br>
<table style="text-align: left; width: 100%;" border="1" cellspacing="2"
 cellpadding="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">Before with default behavior
showing the image of the live visual control with a border<br>
      </td>
      <td style="vertical-align: top;">With plugin showing custom edit
part with an icon and label and no boder<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><img
 style="border: 1px solid ; width: 365px; height: 180px;"
 alt="originalGEF" src="images/OriginalGraphicalEditPart.JPG"><br>
      </td>
      <td style="vertical-align: top;"><img
 style="border: 1px solid ; width: 356px; height: 180px;"
 alt="GraphicalEditPart" src="images/GraphicalEditPart.JPG"><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
<ul>
  <li>
    <h3>Code generation</h3>
  </li>
  <ul>
    <li>Code generation uses decoder classes to mediate between the
visual editor's model and the Java source model.&nbsp; This tutorial
shows how to create a custom code generation rule for the <span
 style="font-style: italic;">text </span>property of <span
 style="font-style: italic;">MyCustomPrompter </span>so that it has an
additional comment placed on the line with the set method.&nbsp; This
is the string <span style="color: rgb(0, 102, 0);">// Prompter Text
Property</span><br>
    </li>
  </ul>
</ul>
<br>
<table style="text-align: left; width: 100%;" border="1" cellspacing="2"
 cellpadding="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">Before with default code
generation behavior<br>
      </td>
      <td style="vertical-align: top;">With plugin showing the extra
comment line code generated for the setText(String) method<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><span
 style="color: rgb(153, 0, 0);"> private void </span>createMyCustomPrompter()
{<br>
&nbsp; myCustomPrompter = <span style="color: rgb(153, 0, 0);">new </span>MyCustomPrompter(sShell,
SWT.<span style="font-style: italic; color: rgb(51, 51, 255);">NONE</span>);&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <br>
&nbsp; myCustomPrompter.setText(<span style="color: rgb(51, 51, 255);">"Text
Value"</span>);<br>
}</td>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;"><span style="color: rgb(153, 0, 0);">private
void</span> createMyCustomPrompter() {</span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp; myCustomPrompter = <span
 style="color: rgb(153, 0, 0);">new </span>MyCustomPrompter(sShell,
SWT.<span style="font-style: italic; color: rgb(51, 51, 255);">NONE</span>);&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; </span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;"></span><span
 style="font-family: monospace;">&nbsp; myCustomPrompter.setText(<span
 style="color: rgb(51, 51, 255);">"Text value"</span>); <span
 style="color: rgb(0, 153, 0);">// Prompter Text Property </span></span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;">}</span><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<ul>
  <li>
    <h3>Preferred Event</h3>
  </li>
</ul>
<ul>
  <ul>
    <li><span style="font-style: italic;">MyCustomPrompter </span>signals
an event when its button is pressed.&nbsp;&nbsp; Listeners can register
interest in this with the method <span style="font-style: italic;">addButtonSelectionListener(ButtonSelectionListener
aListener)</span> and remove interest with the method <span
 style="font-style: italic;">removeButtonSelectionListener(ButtonSelectionListener
aListener).&nbsp; </span>The Visual Editor will automatically detect
this event because the naming convention of the methods and the
listener class follows the JavaBeans specification.&nbsp; The event
will be available from the list of all available events for the custom
control, however it is included in the list that has everything from
mouse through keyboard and paint events.&nbsp; This tutorial shows how
to promote the event to the list of <span style="font-style: italic;">preferred
      </span>events whereupon it will be shown on the <span
 style="font-style: italic;">Add Events </span>menu for the class.</li>
  </ul>
</ul>
<br>
<table style="text-align: left; width: 100%;" border="1" cellspacing="2"
 cellpadding="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">Before where the Events menu has
no preferred events<br>
      </td>
      <td style="vertical-align: top;">With plugin the Events menu has <span
 style="font-style: italic;">buttonSelected </span>as a preferred event<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><img
 style="border: 1px solid ; width: 500px; height: 320px;"
 alt="OriginalEventsMenu" src="images/OrignalEventsMenu.JPG"><br>
      </td>
      <td style="vertical-align: top;"><img
 style="border: 1px solid ; width: 500px; height: 320px;"
 alt="EventsMenuAfter" src="images/EventsMenuAfter.JPG"><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<h1>Table of Contents</h1>
<p><a href="#Getting_started">Getting Started</a><br>
<a href="#%0A_the_Plugin">Creating the Plugin</a><br>
<a href="#The_Custom_Widget">The Custom Widget</a><br>
<a href="#Creating_a_Classpath_Container">Creating a Classpath Container</a><br>
<a href="#Adding_a_palette_category_for_our_widget">Adding a palette
category for our widget</a><br>
<a href="#Using_an_ENUM_cell_editor">Using an ENUM cell editor</a><br>
<a href="#Creating_A_SWT_cell_editor">Creating a SWT cell editor</a><br>
<a href="#Overriding_a_GEF_edit_part">Overriding a GEF edit part</a><br>
<a href="#Overriding_an_Expression_Decoder">Overriding an Expression
Decoder</a><br>
<a href="#Preferred_Event">Preferred Event</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="Getting_started">Getting started</a></h2>
<p>This tutorial goes go through the steps required to build a plugin
called<b><i> </i></b><i>org.eclipse.ve.example.customwidget</i><span
 style="font-style: italic;"><span style="font-weight: bold;">.&nbsp;&nbsp;&nbsp;
</span></span>The pre-requisites are an Eclipse 3.1 target environment
which has a 3.1 codebase for the Visual Editor, GEF and EMF
installed.&nbsp; These can be obtained from the <a
 href="http://download.eclipse.org/tools/ve/downloads/index.php">Visual
Editor's download page</a>.<br>
</p>
<p><img
 src="file:///C:/Eclipse_3_1_M5a/eclipse/workspaces/dev_03_09/org.eclipse.ve.example.customwidget/WebContent/images/note.gif"
 alt="Note: " height="13" width="62">&nbsp;&nbsp;&nbsp;
Although the plugin is designed to target 3.1 it can be developed in an
earlier environment such as 3.0.1.&nbsp; The target environment is the
one that is run when the <span style="font-weight: bold;">Run ...
Eclipse Environment </span>is used to launch a runtime
workbench.&nbsp; You can use <span style="font-weight: bold;">Windows-&gt;Preference-&gt;PDE-&gt;Target
Platform</span> to view and change the target environment and <span
 style="font-weight: bold;">Help About </span>to see the version of
Eclipse.<br>
</p>
<p>The completed plugin can be obtained separately as described in the
section <a href="#A_complete_example">A complete example</a><br>
</p>
<p></p>
<h2><a name="Creating_the_Plugin">Creating the Plugin</a></h2>
<p>This section describes how to build the plugin <span
 style="font-style: italic;">org.eclipse.ve.example.customwidget.&nbsp;
</span>This will be used to package the CustomWidget itself as well as
the include the extensions required to overide its default
behavior.&nbsp; The end result for users is that they will install this
plugin onto their Eclipse environment and then configure their Java
projects to use it <span style="color: rgb(255, 0, 0);">&lt;&lt; see
section &gt;&gt;.</span><br>
</p>
<p>To create the plugin select open the New Project wizard using the
menu options <span style="font-weight: bold;">File &gt; New &gt;
Project </span>and choose Plug-in Project. as shown in Figure 1.<br>
</p>
<p><img style="width: 207px; height: 65px;" alt="PluginProjectWizard"
 src="images/PluginProjectWizard.JPG"><br>
</p>
<p><br>
On the first page of the creation wizard name the plugin <i>org.eclipse.ve.example.customwidget</i>,
select 3.1
as the target version and select the check box <span
 style="font-style: italic;">Create an OSGi bundle
manifest.&nbsp;&nbsp; </span>Press <span style="font-style: italic;">Next
</span>to bring up the <span style="font-style: italic;">Plug-in-Content
</span>page and enter a plugin name such as <span
 style="font-style: italic;">Customwidget VE Example Plug-in </span>in
the <span style="font-style: italic;">Plugin-In Name </span>text
field.&nbsp; Press <span style="font-style: italic;">Finish </span>to
have the PDE generate the stub plugin.&nbsp; The workbench might then
ask you to switch to the PDE perspective which you can answer <span
 style="font-style: italic;">Yes </span>to.&nbsp; The plugin manifest
editor will then be opened by default.&nbsp; This is an editor that
allows you to view and edit the contents of the files called <span
 style="font-style: italic;">plugin.xml and manifest.mf </span>that
reside within the plugin.&nbsp; These are both important files as they
describe the extension points used and also the list of pre-requisite
plugins.<span style="text-decoration: underline;"><span
 style="text-decoration: underline;"><span
 style="text-decoration: underline;"><span
 style="text-decoration: underline;"><span
 style="text-decoration: underline;"></span></span></span></span></span><br>
</p>
<p>A plugin represents a component that can be installed onto an
Eclipse environment and contributes code.&nbsp; Every plugin has a set
of dependent plugins which is those it requires to function.&nbsp; This
list would typically include pre-requisite plugins with classes or
interfaces extended or any extension points that have been used.&nbsp;
The list of pre-requisite plugins for a plugin extending the visual
editor is:<br>
</p>
<ul>
  <li>org.eclipse.ui</li>
  <li>org.eclipse.core.runtime</li>
  <li>org.eclipse.ve.java.core</li>
  <li>org.eclipse.jdt.core</li>
  <li>org.eclipse.jem</li>
  <li>org.eclipse.jem.proxy</li>
  <li>org.eclipse.ve.cde</li>
  <li>org.eclipse.ve.swt</li>
  <li>org.eclipse.ve.propertysheet</li>
  <li>org.eclipse.gef</li>
  <li>org.eclipse.emf.ecore<br>
  </li>
</ul>
<p><img
 src="file:///C:/Eclipse_3_1_M5a/eclipse/workspaces/dev_03_09/org.eclipse.ve.example.customwidget/WebContent/images/note.gif"
 alt="Note: " height="13" width="62"> The pre-requisite plugin
org.eclipse.ve.swt is not necessarily required by everyone extending
the visual editor.&nbsp; It contains the code that enables the visual
editor to work with the SWT and because <span
 style="font-style: italic;">MyCustomPrompter </span>is an SWT custom
widget the plugin will be extending SWT base behavior.&nbsp; If your
plugin was for a JFC toolkit such as AWT or Swing you would not
necessarily inlude <span style="font-style: italic;">org.eclipse.ve.swt
</span>in your list of dependencies but instead would use <span
 style="font-style: italic;">org.eclipse.ve.jfc.&nbsp; </span>If your
plugin was for an entirely new widget toolkit you might include neither.<br>
</p>
<p>To set up the list of required plugins select the <span
 style="font-style: italic;">Dependencies </span>tab on the plugin
editor, select the <span style="font-style: italic;">Add ... </span>button
beside the list of Required Plug-ins and enter the list of plugins
listed above.<br>
</p>
<p><img style="width: 302px; height: 179px;" alt="PreReqPlugins"
 src="images/PreReqPlugins.JPG"><br>
</p>
<blockquote class="PictureParagraph">
  <blockquote> </blockquote>
</blockquote>
Having create the plugin there are two major steps remaining.&nbsp; The
first is to create the actual custom widget class itself and test it,
and the second is to extend the visual editor to have the customized
behavior described in the <a href="#Introduction">intrduction</a>.<br>
<br>
<h2><a name="The_Custom_Widget">The Custom Widget</a></h2>
<p>The custom widget used in this tutorial extends SWT composite and
has three child controls on it; a label, a text field, and a
button.&nbsp; For this tutorial we used the Visual Editor to build the
custom widget which, although a good exercise in using the Visual
Editor is outside the scope of what this tutorial is designed to cover,
so you download it directly from CVS.&nbsp; You should download the two
classes <a
 href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.ve.examples/org.eclipse.ve.example.customwidget/src/org/eclipse/ve/example/customwidget/prompter/MyCustomPrompter.java?cvsroot=Tools_Project">MyCustomPrompter.java</a>,
and
<a
 href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.ve.examples/org.eclipse.ve.example.customwidget/src/org/eclipse/ve/example/customwidget/prompter/ButtonSelectionListener.java?cvsroot=Tools_Project">ButtonSelectionListener.java</a>
and place them into the plugin prohject in a package <span
 style="font-style: italic;">org.eclipse.ve.customwidget.prompter.&nbsp;
</span>This is illustrated below together with the Visual Editor opened
against the <span style="font-style: italic;">MyCustomPrompter </span>class
to show the three child controls.&nbsp; The package <span
 style="font-style: italic;">org.eclipse.ve.example.customwidget </span>is
where the visual editor classes&nbsp; (such as the specialized
graphical edit part or code generation decoder) will reside, and the
package <span style="font-style: italic;">org.eclipse.ve.customwidget.prompter
</span>is where the classes reside that the user will use to build
their runtime GUIs with.<br>
</p>
<p><img style="border: 1px solid ; width: 714px; height: 376px;"
 alt="RuntimeClasses" src="images/index.7.jpg"><br>
</p>
<p>For deployment the classes <span style="font-style: italic;">MyCustomPrompter
</span>and <span style="font-style: italic;">ButtonSelectionListener </span>will
be packaged in a JAR.&nbsp; To do this select the runtime package and
use the pop up menu option <span style="font-weight: bold;">Export</span>
to bring up the Export wizard.&nbsp; Select JAR file as and name the
JAR file <span style="font-style: italic;">customwidgets.jar.&nbsp; </span>This
JAR file will be placed inside the plugin itself and there are two ways
to do this.&nbsp; The first is to either export the JAR to a temporary
location on your computer and then import it into the project.&nbsp; If
you do this you should import the <span style="font-style: italic;">customwidgets.jar
</span>not as a JAR file as it contains no code of any interest to the
plugin itself, but instead as a raw <span style="font-style: italic;">File</span>.&nbsp;&nbsp;
The reason for this is that the inclusion of the runtime code in the
plugin is not for the benefit of Eclipse and it will never be loaded by
the Visual Editor into the Eclipse JVM.&nbsp; The user of the plugin
will configure their Java project to use the custom prompter which is
described in the later section <a href="#Using_a_classpath_container">Using
a classpath container</a>, <span style="color: rgb(204, 0, 0);"></span>and
the visual editor will insert the JAR into the -classpath of the VM
that it uses to host the Java classes that make up the user's classes.<br>
The second way to ensure that the <span style="font-style: italic;">customwidgets.jar</span>
is included in the plugin that avoids having to export to the file
system and then re-import as a file, is to export straight to the
directory used by the plugin itself.&nbsp; To see the location of the
plugin you can open its properties and select Info.&nbsp; The figure
below shows an example of this where the workbench location is
D:\temp\tutorial and the JAR wizard creates customwidgets.jar into the
directory used by the <span style="font-style: italic;">org.eclipse.ve.example.customwidget</span>
plugin.<br>
</p>
<img style="border: 1px solid ; width: 465px; height: 502px;"
 alt="JarExport" src="images/index.9.jpg"><br>
<br>
<h3><a name="Testing_MyCustomPrompter"></a>Testing MyCustomPrompter</h3>
<a name="Testing_as_a_JAR"></a>Having created the plugin you can now
test it.&nbsp; To do this create an Eclipse launch configuration using
the <span style="font-weight: bold;">Run </span>menu to bring up the
list of avaliable launch configurations, selecting <span
 style="font-style: italic;">Eclipse Application</span> and <span
 style="font-style: italic;">New </span>and then running this.&nbsp;
This will launch a second Eclipse workbench - the first being your one
that you are using to develop the plugin and the second being the one
you are going to use to deploy the plugin into.&nbsp; In the deployed
workbench create a Java project and add customwidgets.jar to the Java
build path.&nbsp; This is done using the pop-up menu option to open the
<span style="font-weight: bold;">Properties </span>of the project and
selecting <span style="font-weight: bold;">Java Build path ...</span>.&nbsp;
On the build path select the <span style="font-style: italic;">Libraries
</span>tab and <span style="font-style: italic;">Add External Jar ...</span>.&nbsp;
Point to the location of the JAR in the plugin itself - for the example
figure above this would be <span style="font-style: italic;">D:\temp\tutorial\org.eclipse.ve.example.customwidget.customwidgets.jar.</span>&nbsp;
Having added the JAR containing the <span style="font-style: italic;">MyCustomPrompter
</span>class you can now use it within a visual editor class.&nbsp;
Create a test sample using <span style="font-weight: bold;">File &gt;
New &gt; Visual class </span>and selecting <span
 style="font-weight: bold;">SWT &gt; Shell.&nbsp; </span>This will
open the Visual Editor over a class with an SWT shell.&nbsp; Select the
<span style="font-style: italic;">Choose Bean </span>palette entry and
because <span style="font-style: italic;">customwidgets.jar </span>is
in the project's build path (the effective -classpath used by the
Eclipse Java compiler and by the Visual Editor) you can choose <span
 style="font-style: italic;">MyCustomPrompter </span>and drop it onto
the Shell.<br>
<br>
The behavior of <span style="font-style: italic;">MyCustomPrompter </span>is
everything picked up by default as the Visual Editor will realize that <span
 style="font-style: italic;">MyCustomPrompter </span>extends <span
 style="font-style: italic;">org.eclipse.swt.widgets.Composite </span>so
it will be rendered visually and have default property sheet, code
generation, graphical edit part and event menu behavior.&nbsp; The
remainder of this tutorial shows how to customize this behavior as
described in the <a href="#Introduction">introduction</a>.<br>
<br>
<h2><a name="Creating_a_Classpath_Container">Creating a Classpath
Container</a><br>
</h2>
<p>For the test described at the end of the precedding section the <span
 style="font-style: italic;">MyCustomPrompter </span>class was made
available to the user's Java project by them adding it as an external
JAR.&nbsp; This isn't ideal as it requires the user knowing the
location of the plugin directory on their computer and physically
pointing to it.&nbsp; A better way is to use a classpath
container.&nbsp; This allows one-touch configuration of a Java project
to use a named container which handles all the internals of how to
locate the correct runtime code.&nbsp; <br>
</p>
<p>A Java container is a class that implements the JDT interface <span
 style="font-style: italic;">org.eclipse.jdt.core.IClasspathContainer</span>.&nbsp;&nbsp;
It is added to a Java project's build path using the <span
 style="font-style: italic;">Add Library </span>button on the <span
 style="font-style: italic;">Libraries </span>tab and an example of
one used by the Visual Editor is <span style="font-style: italic;">org.eclipse.ve.internal.swt.SWTContainer</span>.&nbsp;&nbsp;
As well as the JDT using the container to locate the runtime classes
the Visual Editor uses this as a marker for extension behavior.&nbsp;
When the Visual Editor opens over a project all of the containers are
scanned and matched against extension points to see if there are any
plugins that wish to contribute to the palette or any other custom
visual editor behavior based on the classes included within the
container.<br>
</p>
<p>This tutorial doesn't create a new container class because the
complexities involved doing this require knowledge of JDT concepts such
as IPath and IClassPathEntry[].&nbsp; It is expected that commercial
quality plugins extending the Visual Editor will create their own
containers in which case the <span style="font-style: italic;">SWTContainer
</span>class is a good example to look at to learn how to do this,
however for simplicitly the visual editor provides a reference
implementation container class&nbsp; <span style="font-style: italic;">org.eclipse.ve.internal.java.core.RegisteredClassPathContainer.&nbsp;
</span>The Registered container uses extension points to determine the
JAR files it will add to the user's build path.<br>
</p>
<p>The user experience is that a container called "Custom Prompter"
will be available for them to add to a Java project's build path.&nbsp;
This is described in the section <a href="#Using_a_classpath_container">Using
a classpath container</a>.&nbsp; The JDT extension point <span
 style="font-style: italic;">org.eclipse.jdt.ui.classpathContainerPage </span>allows
contributions to be made for an entry to appear in the list of
containers and be available for the user to select, as well as the
wizard page that will then appear once <span
 style="font-style: italic;">Next </span>is pressed.&nbsp; The wizard
page is responsible for configuring the project's build path to
actually add the container classpath entry.<br>
</p>
<p>To add the <span style="font-style: italic;">Custom Prompter </span>entry
to the list of available containers add the following to the <a
 href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.ve.examples/org.eclipse.ve.example.customwidget/plugin.xml?cvsroot=Tools_Project">plugin.xml</a>
of the <span style="font-style: italic;">org.eclipse.ve.examples.customwidget
</span>plugin.<br>
</p>
<blockquote> </blockquote>
<pre><br>  <a name="ContainerPageDefinition"></a>&lt;extension<br>         point="org.eclipse.jdt.ui.classpathContainerPage"&gt;<br>      &lt;classpathContainerPage<br><img
 style="width: 24px; height: 13px;" alt="tag1" src="images/tag1.gif">         name="Custom Prompter"<br><img
 style="width: 24px; height: 13px;" alt="tag2" src="images/tag_2.gif">         class="org.eclipse.ve.internal.java.wizard.RegisteredClasspathContainerWizardPage"<br><img
 style="width: 24px; height: 13px;" alt="tag3" src="images/tag_3.gif">         id="org.eclipse.ve.example.PrompterContainer"&gt;<br>      &lt;/classpathContainerPage&gt;<br>   &lt;/extension&gt;  <br></pre>
The name <img style="width: 24px; height: 13px; font-style: italic;"
 alt="tag1" src="images/tag1.gif"><span style="font-style: italic;">
"Custom Prompter"</span> is the user visible String shown in the list
of available libraries from the <span style="font-style: italic;">Add
Library </span>wizard on the <span style="font-style: italic;">Libraries
</span>tab on the <span style="font-style: italic;">Java build
path.&nbsp; </span>In a commercial quality plugin it is expected this
would come from a resource bundle and be externalized for different
locales however this tutorial will hard code it to the literal <span
 style="font-style: italic;">"Custom Prompter"</span>.&nbsp; Once the
user selects a container library to be added and presses <span
 style="font-style: italic;">Next </span>a wizard page is brought up
showing configuration details of the particular container.&nbsp; This
wizard page <span style="font-style: italic;">implements
org.eclipse.jdt.ui.wizards.IClasspathContainerPage</span> and for a
commercial quality plugin it is expected that a custom page would be
written.&nbsp; The visual editor SWT container page
org.eclipse.ve.internal.swt.SWTcontainerWizardPage is a good example to
look at if your intention is to create a full wizard page, however the
visual editor provides an example <span style="font-style: italic;">org.eclipse.ve.internal.java.wizard.RegisteredClasspathContainerWizardPage
</span>that can be used <img style="width: 24px; height: 13px;"
 alt="tag2" src="images/tag_2.gif">.&nbsp;&nbsp; <br>
<br>
The container needs an id that uniquely identifies it within an Eclipse
environment and this tutorial uses&nbsp;<img
 style="width: 24px; height: 13px;" alt="tag3" src="images/tag_3.gif"> <span
 style="font-style: italic;">org.eclipse.ve.example.PrompterContainer.</span><br>
<br>
The RegisteredClasspathContainerWizardPage will add the container
RegisteredClasspathContainer to the build path of the user's project
once they select it.&nbsp; This is a generic container and to identify
it as being an entry that should point to the runtime files required
for the <span style="font-style: italic;">MyCustomPrompter </span>and
its supporting classes requires two further extension points.&nbsp; If
a specific custom container is being used then these are not required.<br>
<br>
The extension point <span style="font-style: italic;">org.eclipse.jdt.core.classpathContainerInitializer
</span>specificies a container initializer that will be used by the JDT
to configure containers.&nbsp; The following lines should be added to
the plugin.xml for the <span style="font-style: italic;">org.eclipse.ve.examples.customwidget
</span>plugin.<br>
<br>
<pre>   &lt;extension<br>         point="org.eclipse.jdt.core.classpathContainerInitializer"&gt;<br>      &lt;classpathContainerInitializer<br><img
 style="width: 24px; height: 13px;" alt="" src="images/tag1.gif">      class="org.eclipse.ve.internal.java.core.RegisteredClasspathContainerInitializer"<br><img
 style="width: 24px; height: 13px;" alt="" src="images/tag_2.gif">      id="org.eclipse.ve.example.PrompterContainer"&gt;<br>      &lt;/classpathContainerInitializer&gt;<br>   &lt;/extension&gt;   <br>   <br> </pre>
The class used is a reference implementation provided by the Visual
Editor and is <img style="width: 24px; height: 13px;" alt=""
 src="images/tag1.gif"> <span style="font-style: italic;">org.eclipse.ve.internal.java.core.RegisteredClasspathcontainerInitializer.&nbsp;
</span>The id used must match the one described earlier as the id of
the container wizard page.&nbsp; This tutorial is using <img
 style="width: 24px; height: 13px;" alt="" src="images/tag_2.gif"> <span
 style="font-style: italic;">org.eclipse.ve.example.PrompterContainer.<br>
<br>
</span>Having configured the wizard page and the container initializer
this will now add an instance of the RegisteredClasspathContainer to
the user's build path of their Java project.&nbsp; This need to be told
where to locate the jars that contain the runtime code.&nbsp; There is
an extension point used by the RegisteredClasspathContainer class named
<span style="font-style: italic;">org.eclipse.ve.java.core.registrations.&nbsp;
</span>To use it add the following lines to the plugin.xml.&nbsp; Note
that if a true container implementation is being done instead then this
extension point is not required - it is only used by the
RegisteredClasspathContainer.&nbsp; For example, the project
org.eclipse.ve.swt that defines the SWT extensions for the visual
editor has its own custom behavior and does not require use of this
extension point.&nbsp; <span style="font-style: italic;"></span><br>
<pre> &lt;extension<br>         point="org.eclipse.ve.java.core.registrations"&gt;<br>      &lt;registration<br><img
 style="width: 24px; height: 13px;" alt="" src="images/tag1.gif">       container="org.eclipse.ve.example.PrompterContainer"<br><img
 style="width: 24px; height: 13px;" alt="" src="images/tag_2.gif">       description="Custom Prompter"&gt;<br><img
 style="width: 24px; height: 13px;" alt="" src="images/tag_3.gif">     &lt;<a
 name="library_definition"></a>library runtime="customwidgets.jar"/&gt;<br>      &lt;/registration&gt;<br>   &lt;/extension&gt; <br></pre>
The&nbsp; name of the container must match the id used when the
classpath wizard page and container initializer were defined.&nbsp;
This tutorial is using <img style="width: 24px; height: 13px;" alt=""
 src="images/tag1.gif"> <span style="font-style: italic;">org.eclipse.ve.example.PrompterContainer.&nbsp;&nbsp;
</span>The container needs a description that will appear in the Java
build path list of classpath entries and the tutorial uses the hard
coded literal <img style="width: 24px; height: 13px;" alt=""
 src="images/tag_2.gif"> <span style="font-style: italic;">"Custom
Prompter".&nbsp; </span>The plugin element&nbsp;<img
 style="width: 24px; height: 13px;" alt="" src="images/tag_3.gif">
&lt;library runtime="customwidgets.jar".&gt; describes the actual
location of the runtime jars that container the <span
 style="font-style: italic;">MyCustomPrompter </span>class.&nbsp; If
there are multiple jars then the entry can be repeated.&nbsp;&nbsp; The
location of the jar is relative to the plugin itself, so if <span
 style="font-style: italic;">customwidgets.jar </span>were in a
directory called <span style="font-style: italic;">jars </span>within
the plugin then the entry would be runtime="jars/.customwidgets.jar".<br>
<br>
Having update the plugin.xml file to define the classpath container the
next step is to test this.<br>
<h2><a name="Using_a_classpath_container"></a>Using a classpath
container<br>
</h2>
<p>Launch the Eclipse Application workbench using the <span
 style="font-weight: bold;">Run </span>menu to open the runtime
environment in which the <span style="font-style: italic;">MyCustomPrompter
</span>class can be tested.&nbsp; If you have previously done this and
created a Java project with a build path entry pointing to the <span
 style="font-style: italic;">customwidgets.jar</span> as described
earlier remove the jar from the build path.&nbsp; Otherwise create a
new Java project.<br>
</p>
<p>The next steps are the experience that a user of the plugin will
take to configure a Java project to work with the <span
 style="font-style: italic;">MyCustomPrompter </span>custom
control.&nbsp; Open the properties for the Java project using the <span
 style="font-weight: bold;">Properties </span>choice on the pop-up
menu and select <span style="font-style: italic;">Java Build Path.</span><span
 style="font-weight: bold;"><span style="font-style: italic;">&nbsp; </span></span>Select
the <span style="font-style: italic;">Libraries </span>tab and choose
the <span style="font-style: italic;">Add Library </span>button.&nbsp;
This will bring up a list of all known Java containers which will
include the <span style="font-style: italic;">Custom Prompter</span>
as defined using the extension point
org.eclipse.jdt.ui.classpathcontainerPage <a
 href="#ContainerPageDefinition">earlier.</a> The figure below shows
the Java build path for a project called <span
 style="font-style: italic;">Test </span>and the Custom Prompter
displayed in the <span style="font-style: italic;">l</span>list of
available libraries opened from the <span style="font-style: italic;">Add
Library </span>button<span style="font-style: italic;"><span
 style="font-weight: bold;"><span style="font-style: italic;"><span
 style="font-weight: bold;"><br>
</span></span></span></span></p>
<p><img style="width: 656px; height: 437px;" alt=""
 src="images/CustomPrompterContainerPage.JPG"><br>
<span style="font-style: italic;"><span style="font-weight: bold;"><span
 style="font-style: italic;"><span style="font-weight: bold;"></span></span></span></span></p>
<p class="PictureParagraph"></p>
<p>Select the <span style="font-style: italic;">Custom Prompter </span>and
press Next to view the wizard page <span style="font-style: italic;">org.eclipse.ve.internal.java.wizard.RegisteredClasspathContainerWizardPage
</span>defined <a href="#ContainerPageDefinition">earlier</a>.&nbsp;
This is a generic example of a page and shows details of the jar that
will be added by the page.&nbsp; For commercial quality plugins it is
expected that this page however will be a specific to the particular
plugin.&nbsp; <br>
</p>
Pressing Finish on the wizard page will configure the project (using
the RegisteredClasspathcontainerInitializer defined earlier) to include
the container <span style="font-style: italic;">RegisteredClasspathContainer
</span>together with the id of<span style="font-style: italic;">
org.eclipse.ve.examples.PrompterContainer.&nbsp; </span>Expanding the
container in the project's build path will show that it points to the
correct location for the customwidgets.jar as described in the <span
 style="font-family: monospace;">&lt;library
runtinme="customwidgets.jar"&gt;</span> plugin.xml tag described <a
 href="#library_definition">earlier</a>.<br>
<br>
<img style="width: 267px; height: 138px;" alt=""
 src="images/TestProjectBuildPath.JPG"><br>
<br>
<img
 src="file:///C:/Eclipse_3_1_M5a/eclipse/workspaces/dev_03_09/org.eclipse.ve.example.customwidget/WebContent/images/note.gif"
 alt="Note: " height="13" width="62"> The figures above for configuring
the project Test's build path to include the <span
 style="font-style: italic;">Custom Prompter</span> container entry
show two other containers, namely the <span style="font-style: italic;">JRE
System library</span> and the <span style="font-style: italic;">Standard
Widget Toolkit.</span>&nbsp;&nbsp; The JRE container will be present on
the Java project by default when it is first created, however the SWT
container will not be.&nbsp; This is a container defined by the plugin
project <span style="font-style: italic;">org.eclipse.ve.swt</span>
that enables the Visual Editor to work with the SWT.&nbsp; If you
created the Test project in the step <a
 href="#Testing_MyCustomPrompter">Testing the custom prompter</a>
described earlier when you created the test class using the <span
 style="font-style: italic;">New Visual Class Wizard</span><span
 style="font-weight: bold;"><span style="font-style: italic;"><span
 style="font-weight: bold;"> </span></span><span
 style="font-weight: bold;"></span></span>and selected SWT application
the wizard automatically added the SWT container to the project's build
path as required.&nbsp; SWT support for the Visual Editor can be
manually added by using the steps described above but selecting <span
 style="font-style: italic;">Standard Widget Toolkiit </span>instead
of <span style="font-style: italic;">Custom Prompter </span>on the<span
 style="font-style: italic;"> Add Library </span>wizard page.&nbsp;
Adding dependent containers (CustomPrompter requires SWT) is not
something that is supported by the reference implementation of
RegisteredClassPathContainer and it is expected that commercial quality
plugins will provide their own container class with the required logic
to ensure consistency of dependent containers in the user's build path.<br>
<br>
Having configured the Test project to use the <span
 style="font-style: italic;">Custom Prompter</span> container you can
now test it by creating an SWT Shell from the <span
 style="font-style: italic;">New Visual Class Wizard </span>and
dropping <span style="font-style: italic;">MyCustomPrompter </span>using
the <span style="font-style: italic;">Choose Bean ... </span>palette
entry.&nbsp; the next step is to configure the palette so that a new
category called <span style="font-style: italic;">Custom </span>is
added that has an entry for the <span style="font-style: italic;">MyCustomPrompter
</span>class.<br>
<br>
<h2><a name="Adding_a_palette_category_for_our_widget">Adding a palette
category for MyCustomPrompter</a><br>
</h2>
The visual editor's palette is described by an EMF model.&nbsp; EMF
serializes to&nbsp; <a
 href="http://www.omg.org/technology/documents/formal/xmi.htm">XMI</a>
whih is an XML representation of a graph of EMF objects.&nbsp; Plugins
can define their own XMI files that describe the categories to be added
to the palette, the groups these belond to, and the actual entries
themselves.&nbsp; For the org.eclipse.ve.examples.customwidgets plugin
there will be a palette XMI file that describes the single category and
class to add.<br>
<br>
Create a file called customprompter.xmi in the plugin and open it with
a text editor.&nbsp; The data for the file is shown below and can be
downloaded directly from <a
 href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.ve.examples/org.eclipse.ve.example.customwidget/customprompter.xmi?cvsroot=Tools_Project">CVS</a>
to avoid re-entry.<br>
<br>
<pre>  &lt;xmi:XMI xmi:version="2.0" <br>    xmlns:xmi="http://www.omg.org/XMI" <br>    xmlns:palette="http:///org/eclipse/ve/internal/cde/palette.ecore"<br>    xmlns:utility="http:///org/eclipse/ve/internal/cde/utility.ecore"&gt;  <br><img
 style="width: 24px; height: 13px;" alt=""
 src="file:///C:/Eclipse_3_1_M5a/eclipse/workspaces/dev_03_09/org.eclipse.ve.example.customwidget/WebContent/images/tag1.gif">  &lt;palette:CategoryCmp&gt;<br><img
 style="width: 24px; height: 13px;" alt=""
 src="file:///C:/Eclipse_3_1_M5a/eclipse/workspaces/dev_03_09/org.eclipse.ve.example.customwidget/WebContent/images/tag_2.gif">  &lt;categoryLabel xsi:type="utility:ConstantString" string="Custom"/&gt;<br>      &lt;cmpGroups xsi:type="palette:GroupCmp"&gt;<br>    <br><img
 style="width: 23px; height: 13px;" alt=""
 src="file:///C:/Eclipse_3_1_M5a/eclipse/workspaces/dev_03_09/org.eclipse.ve.example.customwidget/WebContent/images/tag_3.gif">      &lt;cmpEntries xsi:type="palette:AnnotatedCreationEntry" xmi:id="entry2" icon16Name="platform:/plugin/org.eclipse.ve.example.customwidget/icons/custom.gif"&gt;<br>          &lt;objectCreationEntry xsi:type="palette:EMFCreationToolEntry"<br><img
 style="width: 24px; height: 13px;" alt=""
 src="file:///C:/Eclipse_3_1_M5a/eclipse/workspaces/dev_03_09/org.eclipse.ve.example.customwidget/WebContent/images/tag_4.gif">         creationClassURI<b>=</b>"java:/org.eclipse.ve.example.customwidget.prompter#MyCustomPrompter"/&gt;<br><img
 style="width: 24px; height: 13px;" alt="" src="images/tag_5.gif">       &lt;entryLabel xsi:type="utility:ConstantString" string="Prompter"/&gt;<br>        &lt;/cmpEntries&gt; <br>      <br>      &lt;/cmpGroups&gt;<br>    &lt;/palette:CategoryCmp&gt;<br>  &lt;/xmi:XMI&gt;</pre>
The&nbsp;<img style="width: 24px; height: 13px;" alt=""
 src="images/tag1.gif"> &lt;palette:categoryCmp&gt; tag describes a
palette category that has a label and groups, each group containing a
number of entries.&nbsp; In the example for the tutorial the label is
hard coded to the literal&nbsp;<img style="width: 24px; height: 13px;"
 alt="" src="images/tag_2.gif"> <span style="font-style: italic;">"Custom".&nbsp;
</span><img
 src="file:///C:/Eclipse_3_1_M5a/eclipse/workspaces/dev_03_09/org.eclipse.ve.example.customwidget/WebContent/images/note.gif"
 alt="Note: " height="13" width="62"> For a plugin that needed to
support different language locales there is an EMF class
utility:TranslatableString and examples of its usage can be found in
the palette files for the plugin org.eclipse.ve.jfc.<br>
A single group is defined for the Custom category.&nbsp; If multiple
groups are defined the palette demarks these visually with a
separator.&nbsp; The group has a single entry that defines the&nbsp;<img
 style="width: 24px; height: 13px;" alt="" src="images/tag_3.gif">
graphic, the qualified&nbsp;<img style="width: 24px; height: 13px;"
 alt="" src="images/tag_4.gif"> name of the class and the literal <img
 style="width: 24px; height: 13px;" alt="" src="images/tag_5.gif">
string that is displayed on the palette entry.&nbsp; The&nbsp;<img
 style="width: 24px; height: 13px;" alt="" src="images/tag_3.gif">
graphic points to the URL of where the image is located, in this case
the entry points to a file <span style="font-style: italic;">custom.gif
</span>in the <span style="font-style: italic;">icons </span>directory
of the plugin called <span style="font-style: italic;">org.eclipse.ve.example.customwidget.&nbsp;
</span>The graphic used&nbsp;<img style="width: 16px; height: 16px;"
 alt="" src="images/custom.gif"> is available in <a
 href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.ve.examples/org.eclipse.ve.example.customwidget/icons/?cvsroot=Tools_Project">CVS</a>
and you will need to create a folder called <span
 style="font-style: italic;">icons </span>in the plugin and copy it
there.<br>
<br>
<a
 href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.ve.examples/org.eclipse.ve.example.customwidget/icons/?cvsroot=Tools_Project"></a><img
 style="border: 1px solid ; width: 241px; height: 97px;" alt=""
 src="images/IconsFolder.JPG"><br>
<p>
<img src="images/tip.gif" alt="Tip: " height="13" width="62"> Because
XMI files do not have anything to validate them at design time errors
made in their syntax can easily be made that cause runtime problems
that can be hard to trace and debug.&nbsp; The most straightforward way
to write a Visual Editor XMI file is to copy an existing one that is
similar to what you desire and then alter just the parts that need
changing.<br>
</p>
<p>Having create the <span style="font-style: italic;">customprompter.xmi
</span>file we need to enable the Visual Editor to use it.&nbsp; This
is done by associating the palette file with a classpath container, in
our case the Custom Prompter.&nbsp; <br>
</p>
<p>Now that we have our palette xmi file available, we need to
contribute it to the Visual Editor.&nbsp; We do so by adding to the
following extension in the plugin's&nbsp; <a
 href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.ve.examples/org.eclipse.ve.example.customwidget/plugin.xml?cvsroot=Tools_Project">plugin.xml</a>
manifest file.<br>
</p>
<pre>  &lt;extension<br><img style="width: 24px; height: 13px;" alt=""
 src="images/tag1.gif">    point="org.eclipse.ve.java.core.contributors"&gt;<br>    &lt;palette<br><img
 style="width: 24px; height: 13px;" alt="" src="images/tag_2.gif">   container="org.eclipse.ve.example.PrompterContainer"<br><img
 style="width: 24px; height: 13px;" alt="" src="images/tag_3.gif">   categories="<b>customprompter.xmi</b>"/&gt;<br>  &lt;/extension&gt;  	</pre>
<p>The extension point used is&nbsp;<img
 style="width: 24px; height: 13px;" alt="" src="images/tag1.gif"> <span
 style="font-style: italic;">org.eclipse.ve.java.core.contributors. </span>This
has a &lt;palette&gt; child XML tag that points to the id of the&nbsp;<img
 style="width: 24px; height: 13px;" alt="" src="images/tag_2.gif">
container whose inclusion in a project's build path causes the palette
catgories defined in the&nbsp;<img style="width: 24px; height: 13px;"
 alt="" src="images/tag_3.gif"> categories tag to be included. The
palette categories tag is relative to the root of the plugin project,
for example If the palette XMI file is in a folder called <span
 style="font-style: italic;">palette </span>then the entry would be <span
 style="font-family: monospace;">categories="palette/customprompter.xmi".</span><br>
</p>
<p>When the Visual Editor starts it scans all of the project's build
path entries and for any that are containers it looks to see whether
there are any palette files.&nbsp; These are combined together to
create the overall palette.<br>
</p>
<p>Advanced &gt;&gt; As well as describing palette entries directly it
is possible to configure the Visual Editor to have an
IConfigurationContribution that has the ability to manipulate both the
-classpath of the Visual Editor's VM and the palette with more fine
control.&nbsp; An example of where this is done is by SWT that has to
add runtime packages such as DLLs or packages to the VM's arguments, or
a plugin that might wish to remove some of the existing palette
entriies (such as the JFC ones) for projects configured with their
container present.<br>
</p>
<p>Advanced&gt;&gt; As well as defining containers to be the trigger
point for Visual Editor custom behavior you can also use plugins by
direct name.&nbsp; An example of where you might do this is if you were
extending the Visual Editor to work with a set of classes that were
containined in a specific plugin, so the user experience to enable a
Java project would be to add a dependent plugin rather than a classpath
container.&nbsp; An example of this might be something like a PDE type
development environment for the actual end user.<br>
</p>
<h3>Testing the custom palette</h3>
Having modified the manifest of the example plugin to include the
plugin the next step is so test it.&nbsp; Do this by launching the
Eclipse Application workbench and creating, or re-opening, a class
MyShell that was created from the <span style="font-style: italic;">New
Visual Class <span style="font-style: italic;">Wizard </span></span>as
an SWT application.&nbsp; The Visual Editor should detect that the
container with an id of <span style="font-style: italic;">org.eclipse.ve.example.PrompterContainer
</span>is in the project's build path and include the palette
categories contained in the <span style="font-style: italic;">custompalette.xmi
</span>file.&nbsp; This is shown in the figure below where the Prompter
palette entry has been selected and dragged out onto the Shell.&nbsp; <br>
<br>
<img style="width: 503px; height: 439px;" alt=""
 src="images/CustomPalette.JPG"><br>
<br>
<img style="width: 63px; height: 13px;"
 src="file:///C:/Eclipse_3_1_M5a/eclipse/workspaces/dev_03_09/org.eclipse.ve.example.customwidget/WebContent/images/note.gif"
 alt="Note: "> When you llaunch the Eclipse Application workspace use
the -clean option, as each time the plugin.xml manifest file has
changed we need to be sure the runtinme Eclipse environment clears its
cache'd manifest details<br>
<br>
At this point in the tutorial you should have defined a classpath
container that the user can configure a Java project with to include
the jar containing the runtime code for the <span
 style="font-style: italic;"><span style="font-style: italic;"><span
 style="font-style: italic;">MyCustomPrompter </span></span></span>class.&nbsp;
The extension point <span style="font-style: italic;">org.eclipse.ve.java.core.contributors
</span>has been used to point to the location of a palette XMI file
that contains a category with an entry for the class.<br>
<br>
The next steps are to configure the Visual Editor so that <span
 style="font-style: italic;">MyCustomPrompter </span>has custom
behavior over and above that it inherits by virtue of extending <span
 style="font-style: italic;">org.eclipse.swt.widgets.Composite</span>.<br>
<h2><a name="Using_an_ENUM_cell_editor">Enumerated values for the <span
 style="font-style: italic;">type</span> property</a></h2>
<p><span style="font-family: monospace;">MyCustomPrompter </span>class
has an <i>int</i> property named <i style="font-weight: bold;">type</i><span
 style="font-weight: bold;">
</span>with <i>getType</i>() and <i>setType</i>(int aType)
methods.&nbsp; While the signature of <i>setType</i> allows ito accept
any int, the class itself only works with one of the three values 0, 1,
or 2 The definition of the the values is held in three static constants
on the <span style="font-family: monospace;">MyPrompterClass</span>.<br>
</p>
<pre><span style="color: rgb(153, 51, 0);">public final static int</span> <span
 style="font-style: italic; color: rgb(51, 51, 255);">DOTS </span>= 0;<br><span
 style="color: rgb(153, 51, 0);">public final static int</span> <span
 style="color: rgb(51, 51, 255); font-style: italic;">MORE </span><span
 style="font-style: italic;">= </span>1;<br><span
 style="color: rgb(153, 51, 0);">public final static int</span> <span
 style="color: rgb(51, 51, 255); font-style: italic;">OPEN </span>= 2;<br></pre>
<p>The significance of the three values is that they alter the button
text for <span style="font-family: monospace;">MyCustomPrompter to </span>be
either "...", "More", or "Open" respectively.&nbsp;&nbsp; The following
code shows this for <span style="font-family: monospace;">MyCustomPrompter</span>'s
<span style="font-family: monospace;">setType(int type)</span> method.<br>
</p>
<pre><span style="color: rgb(153, 0, 0);">public void</span> setType (<span
 style="color: rgb(153, 0, 0);">int </span>type) {<br>  <span
 style="color: rgb(153, 0, 0);">switch</span> (type) {<br>    <span
 style="color: rgb(153, 0, 0);">case </span><span
 style="font-style: italic; color: rgb(51, 51, 255);">DOTS</span>: button.setText(<span
 style="color: rgb(51, 51, 255);">"..."</span>);<br>      <span
 style="color: rgb(153, 0, 0);">break</span>;<br>    <span
 style="color: rgb(153, 0, 0);">case </span><span
 style="font-style: italic; color: rgb(51, 51, 255);">MORE</span>: button.setText(<span
 style="color: rgb(51, 51, 255);">"More"</span>);<br>      <span
 style="color: rgb(153, 0, 0);">break</span>;<br>    <span
 style="color: rgb(153, 0, 0);">case </span><span
 style="font-style: italic; color: rgb(51, 51, 255);">OPEN</span>: button.setText(<span
 style="color: rgb(51, 51, 255);">"Open"</span>);<br>      <span
 style="color: rgb(153, 0, 0);">break</span>;<br>    <span
 style="color: rgb(153, 0, 0);">default</span>:<br>      <span
 style="color: rgb(153, 0, 0);">throw new</span> IllegalArgumentException(<span
 style="color: rgb(51, 51, 255);">"Value "</span> + type + <span
 style="color: rgb(51, 51, 255);">" must be one of 0, 1 or 2"</span>);<br>  }<br>}</pre>
<p>Whenever a class is selected in the Visual Editor graphical canvas
or Java Beans tree viewer the Properties view will show its properties
and their current values.&nbsp; The view can also be used to edit the
property values, and the Visual Editor has a number of pre-defined
editors associated with specific types.&nbsp; <span
 style="font-style: italic;">int </span>properties for example have an
editor that allows only valid <span style="font-style: italic;">int </span>values
to be entered and by default the Visual Editor will use this whenever
the <span style="font-style: italic;">type </span>property is
selected based on its signature.<br>
</p>
<p>This step of the tutorial describes how to override the default
behavior so that the <span style="font-style: italic;">type </span>property
is edited using a drop down list of the three allowable values.&nbsp;
Also, instead of the values 0, 1 and 2 being displayed as the current
values the literals "Dots", "More" and "Open" will be used
instead.&nbsp; This is described as an objective of the tutorial in the
<a href="#Introduction">Introduction</a>.<br>
</p>
<p>To override the behavior of the <span style="font-style: italic;">type
</span>property so that it has the desired behavior involves using a
BeanInfo class.&nbsp; BeanInfo classes provide a way to describe a
classes' design time behavior and art part of the <a
 href="http://java.sun.com/products/javabeans/reference/api/index.html">JavaBeans
specification</a>.&nbsp; The Visual Editor uses the JavaBeans
specification whereever possible to define edit time behavior for a
JavaBean.&nbsp; <br>
</p>
<p>The BeanInfo specification allows for a class with the same name as
its Java peer to exist that describes the edit time behavior of the
class.&nbsp; For example, the tutorial class is named <span
 style="font-family: monospace;">MyCustomPrompter </span>so there
would be a class <span style="font-family: monospace;">MyCustomPrompterBeanInfo
</span>that implements the interface<span
 style="font-family: monospace;"> java.beans.BeanInfo </span>associated
with it.&nbsp; The simplest way to create this class is to put it in
the same package as the class it describes (e.g. <span
 style="font-family: monospace;">org.eclipse.ve.example.customwidget</span>)
.&nbsp; Strictly speaking this isn't good physical separation of
behaviors as the BeanInfo classes should be kept apart from the runtime
in a separate package and separate jar so they don't become part of the
end user's actual deployment configuration.&nbsp; The Visual Editor
does support scenarios where the BeanInfo is in separate packages and
separate jars, however for the purpose of this tutorial the class <span
 style="font-family: monospace;">org.eclipse.ve.examples.customwidget.MyCustomPrompterBeanInfo</span>
will be created that extends the abstract superclass <span
 style="font-family: monospace;">java.beans.SimpleBeanInfo</span>.<br>
</p>
The full source code for the BeanInfo can be downloaded from<span
 style="text-decoration: underline;"> </span><a
 href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.ve.examples/org.eclipse.ve.example.customwidget/src/org/eclipse/ve/example/customwidget/prompter/MyCustomPrompterBeanInfo.java?cvsroot=Tools_Project">CVS.</a>&nbsp;
A BeanInfo class is responsible for describing the list of properties
used by a tool such as the Visual Editor, and also their edit time
behavior.&nbsp; This is done by specializing the method<span
 style="font-family: monospace;"> PropertyDescriptor[]
getPropertyDescriptors()</span>.&nbsp; The method returns an array of <span
 style="font-family: monospace;">java.beans.PropertyDescriptor</span>
objects, each one representing an item that will appear as a row in the
Properties view and containing information about its display name, the
Java get and set method associated with the property, as well as the
rules for how the property shoud be edited.&nbsp; The specification
allows support for editing behavior is provided by having a <span
 style="font-family: monospace;">java.beans.PropertyEditor</span>
defined against the <span style="font-family: monospace;">PropertyDescriptor</span>,
and while the Visual Editor will work correctly if a <span
 style="font-family: monospace;">PropertyEditor </span>class has been
defined it also supports a shorthand notation for describing a list of
enumerated values because this pattern occurs frequently in widget
libraries (for example orientation properties on scroll bars, alignment
values on layout constraints, etc...) and is the pattern used by the
MyCustomPrompter's <span style="font-style: italic;">type </span>property.&nbsp;
This shorthand notation involves defining a key value pair on the
PropertyDescriptor, the key of which is the string literal <span
 style="font-style: italic;">enumerationValues </span>and the value of
which is an array of tri values.&nbsp; The structure of the array is a
repeating set of <span style="font-weight: bold;">displayName, value,
initializationString</span>.&nbsp; The displayName is the user visible
string shown to the user in the Properties view, the value is the
actual object that identifies the trivalue against a live property
setting, and the initializationString is the fully qualified code
fragment that is generated as argument to the property's set
method.&nbsp; This is illustrated below in the method <span
 style="font-family: monospace;">getPropertyDescriptors() </span>for
the class <span style="font-family: monospace;">MyCustomPrompterBeanInfo</span>.<br>
<pre>  <span style="color: rgb(153, 0, 0);">public </span>PropertyDescriptor[] getPropertyDescriptors() {<br>		<br>    <span
 style="color: rgb(153, 0, 0);">try </span>{		<br>      PropertyDescriptor[] result = <span
 style="color: rgb(153, 0, 0);">new </span>PropertyDescriptor[2]; <br>		<br>      result[0] = <span
 style="color: rgb(153, 0, 0);">new </span>PropertyDescriptor(<span
 style="color: rgb(51, 51, 255);">"text"</span>,MyCustomPrompter.class);<br>      result[1] = <span
 style="color: rgb(153, 0, 0);">new </span>PropertyDescriptor<span
 style="font-weight: bold;">(<span style="color: rgb(51, 51, 255);">"type"</span></span>,MyCustomPrompter.class);<br>		<br>      result[1].setValue(<img
 style="width: 24px; height: 13px;" alt=""
 src="file:///C:/Eclipse_3_1_M5a/eclipse/workspaces/dev_03_09/org.eclipse.ve.example.customwidget/WebContent/images/tag1.gif"><span
 style="color: rgb(51, 51, 255);">"enumerationValues"</span>, <span
 style="color: rgb(153, 0, 0);">new </span>Object[] {<br><img
 style="width: 24px; height: 13px;" alt=""
 src="file:///C:/Eclipse_3_1_M5a/eclipse/workspaces/dev_03_09/org.eclipse.ve.example.customwidget/WebContent/images/tag_2.gif">    <span
 style="color: rgb(51, 51, 255);">"Dots"</span>, <span
 style="color: rgb(153, 0, 0);">new </span>Integer(MyCustomPrompter.<span
 style="color: rgb(51, 51, 255); font-style: italic;">DOTS</span>), <span
 style="color: rgb(51, 51, 255);">"org.eclipse.ve.example.customwidget.prompter.MyCustomPrompter.DOTS"</span>,<br><img
 style="width: 24px; height: 13px;" alt=""
 src="file:///C:/Eclipse_3_1_M5a/eclipse/workspaces/dev_03_09/org.eclipse.ve.example.customwidget/WebContent/images/tag_3.gif">    <span
 style="color: rgb(51, 51, 255);">"More"</span>, <span
 style="color: rgb(153, 0, 0);">new </span>Integer(MyCustomPrompter.<span
 style="color: rgb(51, 51, 255); font-style: italic;">MORE</span>), <span
 style="color: rgb(51, 51, 255);">"org.eclipse.ve.example.customwidget.prompter.MyCustomPrompter.MORE"</span>,<br><img
 style="width: 24px; height: 13px;" alt="" src="images/tag_4.gif">    <span
 style="color: rgb(51, 51, 255);">"Open"</span>, <span
 style="color: rgb(153, 0, 0);">new </span>Integer(MyCustomPrompter.<span
 style="color: rgb(51, 51, 255); font-style: italic;">OPEN</span>), <span
 style="color: rgb(51, 51, 255);">"org.eclipse.ve.example.customwidget.prompter.MyCustomPrompter.OPEN"</span>							      			<br>      });<br>			<br>      <span
 style="color: rgb(153, 0, 0);">return </span>result;<br>    } <span
 style="color: rgb(153, 0, 0);">catch </span>(IntrospectionException e) {			<br>      e.printStackTrace();<br>      <span
 style="color: rgb(153, 0, 0);">return null</span>;<br>    }<br>}<br></pre>
<p>The getPropertyDescriptors() method returns an array of two
properties; <span style="font-style: italic;">text </span>and <span
 style="font-style: italic;">type.&nbsp; </span>The <span
 style="font-style: italic;">type </span>property has a key value pair
assigned to it with a key of <img style="width: 24px; height: 13px;"
 alt="" src="images/tag1.gif"> <span style="font-style: italic;">enumerationValues
</span>and a value that is an array of nine elements.&nbsp; These nine
elements represent the three enumerated values defined as a
tri-values.&nbsp; The first of these is for the value 0 and is defined
as <span style="font-weight: bold;">displayName,value,initString</span>
of&nbsp;<img style="width: 24px; height: 13px;" alt=""
 src="images/tag_2.gif"> "Dots", 0, "0".&nbsp; Instead of hard coding
the 0 however they are coded to be the dynamic lookups of the actual
value from the static constant, allowing the constant to internally
change without requiring BeanInfo modification.&nbsp; The other two
values <img style="width: 24px; height: 13px;" alt=""
 src="images/tag_3.gif"> "More" and <img
 style="width: 24px; height: 13px;" alt="" src="images/tag_3.gif">
"Open" are defined as tri-values for the 4th, 5th and 6th elements of
the array and the 7th, 8th and 9th respectively.<br>
</p>
<p>The <span style="font-family: monospace;">getPropertyDescriptors()</span>
method returns a fully inclusive set of property descriptors for the
JavaBean.&nbsp; For <span style="font-family: monospace;">MyCustomPrompter
</span>the user experience the tutorial wants is that the inherited
properties such as background, foreground, size, etc.. are present on
the class.&nbsp; To achieve this rather than having the <span
 style="font-family: monospace;">getPropertyDescriptors()</span> method
collect the full list of all desired properties, the JavaBeans
specification allows for the method <span
 style="font-family: monospace;">BeanInfo[] getAdditionalBeanInfo()</span>
to be specialized.&nbsp; This returns an array of <span
 style="font-family: monospace;">BeanInfo </span>classes whose
properties are merged together with the result of <span
 style="font-family: monospace;">getPropertyDescriptors() </span>to
create the complete list.<br>
</p>
<pre>  <span style="color: rgb(153, 0, 0);">public </span>BeanInfo[] getAdditionalBeanInfo(){	<br>    <span
 style="color: rgb(153, 0, 0);">try</span>{<br><img
 style="width: 24px; height: 13px;" alt="" src="images/tag1.gif">   <span
 style="color: rgb(153, 0, 0);">return new</span> BeanInfo[]{Introspector.<span
 style="font-style: italic;">getBeanInfo</span>(Control.<span
 style="color: rgb(153, 0, 0);">class</span>)}; <br>    } <span
 style="color: rgb(153, 0, 0);">catch </span>(IntrospectionException e){<br>    <span
 style="color: rgb(153, 0, 0);">return new</span> BeanInfo[0];<br>  }<br></pre>
<img
 src="file:///C:/Eclipse_3_1_M5a/eclipse/workspaces/dev_03_09/org.eclipse.ve.example.customwidget/WebContent/images/note.gif"
 alt="Note: " height="13" width="62">To create the array of BeanInfo
classes representing the set of descriptors to merge one technique
might be to write the code <span style="font-family: monospace;"><span
 style="color: rgb(153, 0, 0);">return new</span> BeanInfo[]
{CompositeBeanInfo.<span style="color: rgb(153, 0, 0);">class</span>,
ControlBeanInfo.<span style="color: rgb(153, 0, 0);">class</span>,
WidgetBeanInfo.<span style="color: rgb(153, 0, 0);">class</span>}</span>.&nbsp;
However doing so would be an attempt to hard code the names of the
BeanInfo classes that may currently be associated with the superclass
chain of <span style="font-family: monospace;">MyCustomPrompter </span>but
would fail if new BeanInfo classes were introduced or removed.&nbsp;
The preferred technique for picking up inherited properties is with the
statement <span style="font-family: monospace;"><span
 style="color: rgb(153, 0, 0);">return new</span>
BeanInfo[]{Introspector.<span style="font-style: italic;">getBeanInfo</span>(Composite.<span
 style="color: rgb(153, 0, 0);">class</span>)</span> where the argument
to the <span style="font-style: italic; font-family: monospace;">getBeanInfo</span><span
 style="font-family: monospace;">(Class aClass) </span>method is the
current bean's superclass.&nbsp; Rather than using <span
 style="font-family: monospace;">Composite </span>as the starting
point for merging inherited properties which is the immediate
superclass of <span style="font-family: monospace;">MyCustomPrompter</span>,
<img style="width: 24px; height: 13px;" alt="" src="images/tag1.gif">&nbsp;
<span style="font-family: monospace;">w</span>is used instead.&nbsp;
The reason for this is that while <span style="font-family: monospace;">MyCustomPrompter
</span>extends Composite it does this more for physical reasons so it
can have its three child controls (the <span
 style="font-family: monospace;">Label</span>, <span
 style="font-family: monospace;">Text </span>and <span
 style="font-family: monospace;">Button</span>), however as a black box
custom class it itself doesn't want to inherit the behavior of <span
 style="font-family: monospace;">Composite </span>such as the ability
to have its layout changed.&nbsp; For this reason it is logically a
subclass of <span style="font-family: monospace;">Control</span>.<br>
<h3>Testing the enumerated values for <span style="font-style: italic;">type</span></h3>
<p>Having updated <span style="font-family: monospace;">MyCustomPrompterBeanInfo.java</span>
this must be re-exported to the <span style="font-style: italic;">customwidgets.jar
</span>file.&nbsp; The customwidgets.jar in the plugin is the one that
the <span style="font-style: italic;">Custom Prompter </span>classpath
container uses in its build path, and if the step of re-creating the <span
 style="font-style: italic;">customwidgets.jar </span>file is not done
when you launch the Eclipse Application you will be using the old
version of the code.&nbsp; Currently Eclipse 3.1 does not support
classpath container entries pointing to folder structures otherwise the
RegisteredClassPathContainer could be coded to automatically look back
into the directory structure of the development environment that
launched it so for now don't forget to keep re-creating the <span
 style="font-style: italic;">customwidgets.jar </span>file each time
any of its contents have changed.<br>
</p>
<img src="images/note.gif" alt="Note: " height="13" width="62"> The
Visual Editor caches information about a class and under some builds
prior to VE 1.1 there are some issues with the cache going stale and
not being automatically refreshed.&nbsp; If this occurs you can
manually recycle the cache by selecting <span
 style="font-weight: bold;">Project &gt; Clean </span>and also
manually removing the directory <span style="font-style: italic;">org.eclipse.ve.beaninfo/cache</span>
from the workbench directory.&nbsp; <br>
<br>
The changes to the <span style="font-family: monospace;">MyCustomPrompterBeanInfo
</span>should mean that the <span style="font-style: italic;">type </span>property
is now rendered with its display name rather than just the raw <span
 style="font-family: monospace;">int </span>value.&nbsp; The
Properties view also will create a drop down list of the three
allowable values.&nbsp; The figure below shows the list of the three
values and when one is selected the argument to the <span
 style="font-family: monospace;">setType(int) </span>method will be
generated with the initializationString as defined in the <span
 style="font-family: monospace;">BeanInfo </span>array.<br>
<br>
<img style="width: 910px; height: 804px;" alt=""
 src="images/index.53.jpg"><br>
<br>
The BeanInfo mechanism provides one technique to override default edit
behavior for a Java class.&nbsp; The Visual Editor uses BeanInfo
classes internally for many of its customizations and it recognizes
externally created BeanInfo classes according to the JavaBeans
specification.<br>
<br>
Some kinds of customzation are not possible through the BeanInfo
mechanism because while it provides a powerful way to describe edit
time behavior and shape for a class the Visual Editor need to be able
to export some of its innermost extension points to the creator of the
Java class, and the BeanInfo mechanism is designed to provide a
portable way of customizing a Java class that can be transported easily
between different IDEs and tools.&nbsp; For example, the next exercise
in the tutorial is to override the behavior that occurs when the <span
 style="font-style: italic;">text </span>property is edited to launch
a dialog editor.&nbsp; This dialog editor will be written using the SWT
and implement Eclipse specific interfaces, so describing it on the
BeanInfo would violate the idea that BeanInfo classes are portable (as
Eclipse interfaces and the SWT are not necessarily available to other
visual design tools).<br>
<br>
For this reason the Visual Editor a separate mechanism to extend a
class's edit time behavior that is done through <span
 style="font-style: italic;">override </span>files<span
 style="font-style: italic;">. </span>This works in conjunction with
the BeanInfo mechanism and provides the ability to leverage any Eclipse
IDE or Visual Editor specific behavior for a class.<span
 style="font-weight: bold;"><span style="font-weight: bold;"><span
 style="font-weight: bold;"></span></span></span><br>
<h2>The Override mechanism</h2>
<p>At the heart of the Visual Editor is an EMF model that describes a
class being edited.&nbsp; This model describes the instances, their
relationships and property settings. Instances of objects in this model
implement <span style="font-family: monospace;">org.eclipse.jem.internal.instantiation.base.IJavaInstance</span>.&nbsp;
For example, a visual editor class that has a <span
 style="font-family: monospace;">Shell </span>whose size is 200,200
will contain two <span style="font-family: monospace;">IJavaInstance </span>objects.&nbsp;
The first of these is for the <span style="font-family: monospace;">Shell
</span>itself and the second is for a <span
 style="font-family: monospace;">Point </span>representing the
size.&nbsp; An EMF relationship between the <span
 style="font-family: monospace;">Shell </span>and the <span
 style="font-family: monospace;">Point </span>instance will exist
whose structural feature represents the size property.<br>
<br>
EMF is a self describing structure, so behind the instance model there
is a meta-model that describes the classes themselves - their methods,
properties, events and hierarchy. The meta-model is created by the
Visual Editor using a combination of reflection and JavaBeans
Introspection.&nbsp; Instances in this metamodel consist of <span
 style="font-family: monospace;">org.eclipse.jem.java.JavaClass</span>&nbsp;
for each Java class.&nbsp; The structural features in the model are
instances of EReference and represent the properties of the Java class.<br>
</p>
<p>There are times when it is necessary to provide additional
information that should be merged in with the EMF model of a
JavaClass.&nbsp; An example of this is a new feature has to be added
over and above those that can be determined by reflection. <br>
</p>
<p>The Visual Editor uses the EMF model of a JavaClass not only to
define its shape but also to define a number of helper classes used by
the Visual Editor.&nbsp; These are typically mediator classes that are
used by the different Visual Editor subsystems.&nbsp; The names of the
mediator classes to use for a given JavaClass are held in the EMF
model, thereby allowing specific classes to have custom behavior for
each subsystem.&nbsp; Rather than hold these directly against the
JavaClass (which is a generic model of Java classes that can be used by
Eclipse plugins other than the Visual Editor)&nbsp; they are held
against decorators classes that annotate the descriptive information of
a class.&nbsp; These can be thought of similar to key value pairs that
hold information rather than provide functionality.&nbsp; <br>
</p>
<p>In summary, override files are used as means to modify, add to or
delete from an EMF JavaClass whose shape is determined through using
standard Java reflection combined with BeanInfo introspection. <br>
</p>
<p>For a plugin to contribute override files its plugin manifest must
implement the extension point <span style="font-style: italic;">org.eclipse.jem.beaninfo.registrations</span>.&nbsp;
This specifies the trigger in the build path that will cause the
overrides to be applied (either a classpath container or pre-requisite
project) as well as the name of a Java package and where override files
for its contents are held within the plugin folder structure.&nbsp; The
code below shows the extension used for the plugin.xml for the <span
 style="font-style: italic;">org.eclipse.ve.examples.customwidget </span>example
in this tutorial.</p>
<p></p>
<pre>    &lt;extension<br>         point="org.eclipse.jem.beaninfo.registrations"&gt;<br><img
 style="width: 24px; height: 13px;" alt="" src="images/tag1.gif">      &lt;registration container="org.eclipse.ve.example.PrompterContainer"&gt;<br>         &lt;override<br><img
 style="width: 24px; height: 13px;" alt="" src="images/tag_2.gif">         package="org.eclipse.ve.example.customwidget.prompter"<br><img
 style="width: 24px; height: 13px;" alt="" src="images/tag_3.gif">         path="overrides/org/eclipse/ve/example/customwidget/prompter"&gt;<br>         &lt;/override&gt;<br>      &lt;/registration&gt;     <br>    &lt;/extension&gt;<br></pre>
<p>The classpath container with an id of <img
 style="width: 24px; height: 13px;" alt="" src="images/tag1.gif"> is
the one used by the <span style="font-style: italic;">Custom Prompter </span>library.&nbsp;
The class being overriden is <span style="font-family: monospace;">org.eclipse.ve.example.customwidget.prompter.MyCustomPrompter</span>
so its<img style="width: 24px; height: 13px;" alt=""
 src="images/tag_2.gif"> package is declared together with&nbsp;<img
 style="width: 24px; height: 13px;" alt="" src="images/tag_2.gif"> a
folder location for where the override files will be stored.&nbsp; The
location of the override folder is up to the creator of the plugin and
is any arbitrary folder, however there is a convention that the Visual
Editor uses where override files are held in a top level folder called <span
 style="font-style: italic;">overrides </span>and then sub folders
created for the package path. &nbsp; <br>
</p>
<p><img style="border: 1px solid ; width: 365px; height: 226px;" alt=""
 src="images/OverrideFileStructure.JPG"><br>
<br>
</p>
<h2><a name="Creating_A_SWT_cell_editor">Custom cell editing for the <span
 style="font-style: italic;">text </span>property</a></h2>
<p>&nbsp;</p>
<p>The <i>MyCustomPrompter</i> class has a String property named <b><i>text</i></b>.&nbsp;
By default the Visual Editor will use a generic String cell editor for
it (see
<a href="#Figure">Figure</a>).&nbsp; But let assume that we want to
develop a specialized cell editor for this property.&nbsp; First we are
going to use the Visual Editor itself to develop the content of the
cell editor (<a
 href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.ve.examples/org.eclipse.ve.example.customwidget/src/org/eclipse/ve/example/customwidget/LabelDialogContent.java?cvsroot=Tools_Project">LabelDialogContent.java</a>).
We will then contribute it to VE so that it uses it as the <b><i>text</i></b>
cell editor for a <i>MyCustomPrompter</i> class.&nbsp; The main
interface fwith the <i>
LabelDialogContent</i> class will be a simple setter/getter: <i>getString</i>
and <i>setString</i> methods.&nbsp; The idea is that when you click on
the <i><b>text</b></i> property on the property sheet, VE will bring
up an instance of this class, call <i>setString</i> with the current
value, and at the end call <i>getString</i> to get the final, edited
value.</p>
<p class="PictureParagraph">
<img border="0" src="images/index.2.jpg" class="PictureStyle"></p>
<p>
VE will require a special Cell Editor based class (we will create a
<a
 href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.ve.examples/org.eclipse.ve.example.customwidget/src/org/eclipse/ve/example/customwidget/CustomLabelEditor.java?cvsroot=Tools_Project">CustomLabelEditor.java</a>
class).&nbsp; This class will wrap our GUI content class as following:</p>
<p>
</p>
<pre>	protected Object openDialogBox(Control cellEditorWindow) {<br>		Display display = cellEditorWindow.getDisplay();<br>		TitleAreaDialog dialog = new TitleAreaDialog(display.getActiveShell()) {<br>			<font
 color="#0000ff">LabelDialogContent content</font>;<br>			protected Control createContents(Composite parent) {<br>				Control result = super.createContents(parent);<br>				setTitleImage(CustomwidgetPlugin.getCustomImage());<br>				setTitle("Prompter's text property editor");<br>				setMessage("Enter the text property, or select a default one by checking the Hello or GoodBye",IMessageProvider.INFORMATION);												<br>				return result;<br>			}<br>			protected Control createDialogArea(Composite parent) {<br>				<font
 color="#0000ff">content = new LabelDialogContent(parent, SWT.NONE);<br>				content.setString(stringValue);<br>				return content;</font><br>			}<br>			<br>			public String toString() {<br>				return content.getString();<br>			}<br>		};	<br>		<br>	<br>		if (dialog.open() != Window.CANCEL) <br>			<font
 color="#0000ff">return createStringJavaObject(dialog.toString());</font><br>		else<br>			return getValue();<br>	}<br></pre>
<p>
The <i>openDialogBox</i> will be called when the text property is
selected in the property sheet.&nbsp; It in turn will open a&nbsp;
JFace dialog with our <i>
LabelDialogContent</i> as the <i>createDialogArea</i>'s content. The <i>openDialogBox</i>
needs to return the new value.&nbsp; <b>This value is not a String</b>.&nbsp;
This value is the VE (EMF) model element representing the string
value.&nbsp; The
<i>createStringJavaObject</i> call will convert the string to an EMF
representation of it.</p>
<p>
<img src="images/note.gif" alt="Note: " height="13" width="62">When we
prime the dialog with a <i>stringValue</i>, we need to figure out what
is the actual value that is represented by the (EMF) model
element.&nbsp; The value of the <i><b>text</b></i> property of a <i>MyCustomPrompter</i>
instance may not be the same value as was set to it in the model.&nbsp;
In fact, it may be the case that the text setting was never set, but it
has some default value; but what is it?&nbsp; To figure this out we
will have to go to the live instance of this String on the target VM
and extract its value.&nbsp; This logic is done with the <i>doSetValue</i>
method. <i>doSetValue</i> is called from the property sheet to prime
the cell editor with the model value.&nbsp; This method uses <i>BeanProxy</i>
APIs to refer to the actual object (on the target VM) that is referred
to by the model's value.&nbsp; IStringBeanProxy is the link between the
EMF String object, and the Target VM String instance.</p>
<pre>	protected void doSetValue(Object value) {<br>		if (value != null){<br>			IStringBeanProxy stringBeanProxy = (IStringBeanProxy) BeanProxyUtilities.getBeanProxy((IJavaInstance) value);<br>			stringValue = stringBeanProxy.stringValue();<br>		}<br>		super.doSetValue(value);<br>	}<br></pre>
<p>&nbsp;</p>
<p>Now that we have the cell editor all coded up, we need to tell VE
when to use it.&nbsp; VE uses xmi <i><b>overrides</b></i> files to do
so.&nbsp; These override files (like the palette contribution) are
quite verbose.&nbsp; Here is a portion of the
<a
 href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.ve.examples/org.eclipse.ve.example.customwidget/overrides/org/eclipse/ve/example/customwidget/prompter/MyCustomPrompter.override?cvsroot=Tools_Project">MyCustomPrompter.override</a>
that relates to the cell editor.&nbsp; We will need to add this file to
our plugin.</p>
<p>
</p>
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br>	:<br>	: <br>  &lt;event:Add  featureName="eStructuralFeatures"&gt;<br>    &lt;addedEObjects xsi:type="ecore:EReference" name="<font
 color="#0000ff">text</font>" unsettable="true"&gt;<br>      &lt;eAnnotations xsi:type="org.eclipse.ve.internal.cde.decorators:<font
 color="#ff0000">BasePropertyDecorator</font>"          <br>          <font
 color="#0000ff">cellEditorClassname</font>="<font color="#ff0000">org.eclipse.ve.example.customwidget</font><font
 color="#0000ff">/org.eclipse.ve.example.customwidget.CustomLabelEditor</font>"/&gt;<br>    &lt;/addedEObjects&gt;<br>   &lt;/event:Add&gt;    <br>  <br>&lt;/xmi:XMI&gt;<br></pre>
<p>We are telling the introspector to annotate the <i><b>text</b></i>
feature with a BasePropertyDecorator EMF class.&nbsp; One of the
properties of this class is a <i>cellEditorClassname</i>.&nbsp; The
value format is as following:
&lt;plugin_name&gt;/&lt;class_name&gt;.&nbsp; The Property Sheet will
use this information to determine which cell editor to use.&nbsp; If
one is not set, it will use the annotation of a super class.</p>
<br>
<p><font face="Arial">The following is the directory structure after
adding the new cell editor classes, and override file:</font></p>
<p class="PictureParagraph">
<img border="0" src="images/index.23.jpg" class="PictureStyle"></p>
<p class="PictureParagraph">&nbsp;</p>
<blockquote>
  <p>&nbsp;</p>
</blockquote>
<p>
<img src="images/note.gif" alt="Note: " height="13" width="62">Make
sure to launch the workspace with the -clean option, as we have changed
the manifest file.</p>
<p>
<img src="images/note.gif" alt="Note: " height="13" width="62">If you
are reading this before a VE1.1 release build, you may have to do a
Project-&gt;clean, close, and reopen the java project that you are
using the <i>
MyCustomPrompter</i> class so that the introspector clear its beaninfo
cache.</p>
<p>&nbsp;</p>
<p>The following is the an image of the cell editor that will now come
up when a user press on the ... button of the text property of a
MyCustomPrompter.</p>
<p class="PictureParagraph">
<img border="0" src="images/index.24.jpg" class="PictureStyle"></p>
<p>&nbsp;</p>
<h2><a name="Overriding_a_GEF_edit_part">Overriding a GEF edit part</a></h2>
<p>&nbsp;</p>
<p>Since the MyCustomPrompter is a SWT Composite, VE will use the
default Composite GEF edit part.&nbsp; In this tutorial we are going to
override the edit part that VE will use for the prompter.&nbsp; This
edit part will not do much, but add to the prompter's image an <font
 color="#0000ff">icon</font>, and some <font color="#0000ff">text</font>
on top of the screen scrape image of the prompter.&nbsp; The new class
<a
 href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.ve.examples/org.eclipse.ve.example.customwidget/src/org/eclipse/ve/example/customwidget/CustomWidgetGraphicalEditPart.java?cvsroot=Tools_Project">CustomWidgetGraphicalEditPart.java</a>
adds this logic as following:</p>
<pre>public class CustomWidgetGraphicalEditPart extends ControlGraphicalEditPart {<br><br>	protected IFigure createFigure() {<br><br>		<font
 color="#0000ff">ImageFigure figure = (ImageFigure) super.createFigure();</font><br>		<font
 color="#0000ff">Label customFigure </font>= <font color="#0000ff">new Label("VE Rules",CustomwidgetPlugin.getCustomImage());</font><br>		customFigure.setForegroundColor(ColorConstants.red);<br>		customFigure.setTextPlacement(PositionConstants.SOUTH);<br>		// ImageFigure has no layout, so we will have to explicitly set the size().<br>		// To get a prefered size (before we hoop up to the hierarchy), Label will need a Font<br>		customFigure.setFont(((GraphicalEditPart)getParent()).getFigure().getFont());<br>		customFigure.setSize(customFigure.getPreferredSize());<br><br>		<font
 color="#0000ff">figure.add(customFigure);</font><br><br>		return figure;<br>	}<br><br>}<br></pre>
<p>The edit part extends the default Control editpart.&nbsp; The reason
we did not extend the default composite one, is that we do not want to
allow one to "drop" anything into our prompter (this widget is still a
Composite).&nbsp; All we do here, is add a Label figure to the main
(screen scraped) figure.</p>
<p>Now that we have a custom edit part we will tell VE to use it by
updating the
<a
 href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.ve.examples/org.eclipse.ve.example.customwidget/overrides/org/eclipse/ve/example/customwidget/prompter/MyCustomPrompter.override?cvsroot=Tools_Project">MyCustomPrompter.override</a>
file as following;</p>
<pre>    <br>  &lt;event:AddMany featureName="eAnnotations"&gt;<br>	  &lt;addedEObjects xsi:type="org.eclipse.ve.internal.cde.decorators:ClassDescriptorDecorator"<br>	    <font
 color="#0000ff">graphViewClassname</font>="<font color="#ff0000">org.eclipse.ve.example.customwidget</font>/<font
 color="#0000ff">org.eclipse.ve.example.customwidget.CustomWidgetGraphicalEditPart</font>"&gt;<br>	  &lt;/addedEObjects&gt; <br>	  <br>	  <font
 color="#c0c0c0">&lt;addedEObjects xsi:type="codeGenHelpers:CodeGenHelperClass" source="codegen.CodeGenHelperClass"<br>           expDecoder="org.eclipse.ve.example.customwidget/org.eclipse.ve.example.customwidget.CustomPrompterDecoder"/&gt;   </font>              <br>  &lt;/event:AddMany&gt;   <br> <br></pre>
<p>We are annotating the class itself with a <i>ClassDescriptorDecorator</i>.&nbsp;
A <i>ClassDescriptorDecorator</i> has a <i>graphViewClassname</i>
property.&nbsp; It uses the &lt;plugin_name&gt;/&lt;class_name&gt;
format.</p>
<p>
&nbsp;</p>
<p>
<img src="images/note.gif" alt="Note: " height="13" width="62">If you
are reading this before a VE1.1 release build, you may have to do a
Project-&gt;clean, close, and reopen the java project that you are
using the <i>
MyCustomPrompter</i> class so that the introspector clear its beaninfo
cache.</p>
<p>&nbsp;</p>
<p>The new edit part will render the Prompter figure with the new Label
figure (text and icon) as following:</p>
<p class="PictureParagraph">
<img border="0" src="images/index.25.jpg" class="PictureStyle"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="Overriding_an_Expression_Decoder">Overriding an Expression
Decoder</a></h2>
<p>&nbsp;</p>
<p>Since the <i>MyCustomPrompter</i> is a SWT Composite, VE will use
the default Composite Decoder to handle the reverse parse, and code
generation needs for the MyCustomPrompter class.&nbsp; For every source
code (AST) expression that is modeled,&nbsp; VE will use an instance of
an expression Decoder.&nbsp; The Decoder uses two helpers: a <i>feature</i>
mapper, and a <i>decoder</i> helper.&nbsp; The <i>feature</i> mapper
is the guy that maps a source code expression to a VE (EMF) model
feature and vice versa.&nbsp; The decoder helper is a specific helper
that knows how to reverse parse (AST) expressions into the VE model, as
well as generate source code from the VE model.&nbsp; The role if the
Decoder itself is to figure out which mapper and helper to use for a
given expression.</p>
<p>&nbsp;</p>
<p>
<img src="images/note.gif" alt="Note: " height="13" width="62">Decoders
to not generate AST trees because in many cases the source code is
generated from a JavaJet (JSP like) templates.&nbsp; These templates
can potentially be modified by users and picked up by VE on the fly.</p>
<p>In this tutorial we will use a simple Decoder. It will add a comment
when generating a <i>setText</i> expression (as a result of changing
the <i><b>text</b></i> property is changed for a MyCustomPrompter
instance).&nbsp; We will first create the
<a
 href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.ve.examples/org.eclipse.ve.example.customwidget/src/org/eclipse/ve/example/customwidget/CustomPrompterDecoderHelper.java?cvsroot=Tools_Project">CustomPrompterDecoderHelper.java</a>
helper.&nbsp; </p>
<pre>public class CustomPrompterDecoderHelper extends SimpleAttributeDecoderHelper {<br>	<br>	/* (non-Javadoc)<br>	 * @see org.eclipse.ve.internal.java.codegen.java.IExpressionDecoderHelper#generate(java.lang.Object[])<br>	 */<br>	public String generate(Object[] noArgs) throws CodeGenException {		<br>		<font
 color="#0000ff">String result = super.generate(noArgs);</font><br>		// Add a comment at the end of the expression <br>		int idx = result.lastIndexOf(';') + 1;<br>		return result.substring(0, idx)<font
 color="#0000ff"> + " </font><font color="#ff0000">// Prompter Text Property</font><font
 color="#0000ff"> " + </font>result.substring(idx, result.length());<br>	}<br>}<br></pre>
<p>The helper is responsible to reverse parse and generate specific
source code.&nbsp; This helper overrides the <i>generate</i> method
for the default helper, and adds the&nbsp; <font color="#ff0000">//
Prompter Text Property
</font><font face="Arial">comment at the end of the expression that is
generated by the <i>SimpleAttributeDecoderHelper</i>.</font></p>
<p><font face="Arial">We will now create a special Decoder,
<a
 href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.ve.examples/org.eclipse.ve.example.customwidget/src/org/eclipse/ve/example/customwidget/CustomPrompterDecoder.java?cvsroot=Tools_Project">CustomPrompterDecoder.java</a>.
This Decoder will use the helper above when the text property is the
one that the Decoder instance is responsible for:</font></p>
<pre>public class CustomPrompterDecoder extends SWTControlDecoder {<br><br>	protected void initialDecoderHelper() {<br>		// if it is the text property that this decoder is decoding, use <br>		// our special helper<br>		if (<font
 color="#0000ff">fFeatureMapper.getFeature(null).getName().equals("text")</font>)<br>			fhelper = new <font
 color="#0000ff">CustomPrompterDecoderHelper</font>(fbeanPart, fExpr, fFeatureMapper, this);<br>		else<br>			super.initialDecoderHelper();<br>	}<br>}<br></pre>
<p>&nbsp;</p>
<p>The last thing that remains to do, is to use the same
<a
 href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.ve.examples/org.eclipse.ve.example.customwidget/overrides/org/eclipse/ve/example/customwidget/prompter/MyCustomPrompter.override?cvsroot=Tools_Project">MyCustomPrompter.override</a>
again and add to it the following:</p>
<pre>    <br>  &lt;event:AddMany featureName="eAnnotations"&gt;<br>	  <font
 color="#c0c0c0">&lt;addedEObjects xsi:type="org.eclipse.ve.internal.cde.decorators:ClassDescriptorDecorator"<br>	    graphViewClassname="org.eclipse.ve.example.customwidget/org.eclipse.ve.example.customwidget.CustomWidgetGraphicalEditPart"&gt;<br>	  &lt;/addedEObjects&gt; </font><br>	  <br>	  &lt;addedEObjects xsi:type="codeGenHelpers:CodeGenHelperClass" source="<font
 color="#0000ff">codegen.CodeGenHelperClass</font>"<br>           <font
 color="#0000ff">expDecoder</font>="<font color="#ff0000">org.eclipse.ve.example.customwidget</font>/<font
 color="#0000ff">org.eclipse.ve.example.customwidget.CustomPrompterDecoder</font>"/&gt;  <font
 color="#c0c0c0"> </font>              <br>  &lt;/event:AddMany&gt;   <br> <br></pre>
<p>We are annotating the MyCustomPrompter class with a
CodeGenHelperClass (this helper is
<a
 href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.ve.java.core/overrides/codegenHelpers.ecore?cvsroot=Tools_Project">dynamically</a>
created by EMF at this point, and hence the different syntax on it).
This annotation tells VE that for a <i>MyCustomPrompter</i>, use the <i>
CustomPrompterDecoder</i> class.</p>
<h2><a name="Preferred_Event">Preferred Event</a></h2>
<p>&nbsp;</p>
<p>The <i>MyCustomPrompter</i> class introduces a <i>buttonSelection</i>
event.&nbsp; VE will figure this out from the class file because the
event follows the JavaBean specification.</p>
<p class="PictureParagraph">
<img border="0" src="images/index.67.gif" class="PictureStyle"></p>
<p>&nbsp;</p>
<p>As such, if you use the Visual Editor to <b>Add Events...</b>, the <i>
buttonSelection</i> event will be there<i>.&nbsp; </i>In this section
we will use the BeanInfo class to denote that this event is
preferred.&nbsp; As such, this event will be available on the Events
context menu:</p>
<p class="PictureParagraph">
<img border="0" src="images/index.68.jpg" class="PictureStyle"></p>
<p>&nbsp;</p>
<p>The
<a
 href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.ve.examples/org.eclipse.ve.example.customwidget/src/org/eclipse/ve/example/customwidget/prompter/MyCustomPrompterBeanInfo.java?cvsroot=Tools_Project">MyCustomPrompterBeanInfo.java</a>
also overrides the <i>getEventSetDescriptors</i> method, and set the
preferred flag to true.</p>
<pre>	public EventSetDescriptor[] getEventSetDescriptors() {<br>		<br>		try{<br>			MethodDescriptor addButtonSelectionMD = new MethodDescriptor(<br>				ButtonSelectionListener.class.getMethod("buttonSelected",<br>				new Class[]{SelectionEvent.class})<br>				);<br>			<font
 color="#0000ff">addButtonSelectionMD.setPreferred(true)</font>;<br>			addButtonSelectionMD.setValue("preferred",Boolean.TRUE);<br>			<br>			EventSetDescriptor addButtonSelectionED = new EventSetDescriptor(<br>					"buttonSelection",<br>					ButtonSelectionListener.class,<br>					new MethodDescriptor[] {addButtonSelectionMD},<br>					MyCustomPrompter.class.getMethod("addButtonSelectionListener",new Class[]{ButtonSelectionListener.class}),<br>					MyCustomPrompter.class.getMethod("removeButtonSelectionListener",new Class[]{ButtonSelectionListener.class})<br>					);<br><br>			addButtonSelectionED.setPreferred(true);<br>			<br>			return new EventSetDescriptor[] {addButtonSelectionED};<br>			<br>		} catch (Exception e){<br>			e.printStackTrace();<br>		}				<br>		<br>		return null;<br>	}<br></pre>
<p>&nbsp;</p>
<h1><a name="A_complete_example"></a>A complete example<br>
</h1>
This tutorial has gone through the steps required to create the
plugin.&nbsp; The completed plugin is also available to download from <a
 href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.ve.examples/org.eclipse.ve.example.customwidget/WebContent/customwidget.zip?cvsroot=Tools_Project">here</a>
or can be obtained directly from CVS.<br>
<br>
<span style="font-style: italic;"></span>To install the plugin from CVS
into an Eclipse development environment attach to the host<span
 style="font-style: italic;"> dev.eclipse.org</span> and repository
path <span style="font-style: italic;">/home/tools</span> using a user
id of <span style="font-style: italic;">anonymous </span>with
no password required.&nbsp; Figure 1 illustrates the CVS perspective in
Eclipse with the CVS Repositories view showing the repository correctly
attached to.&nbsp; To create the new repository use mouse button 2 on
the
CVS Repositories view and select the option <span
 style="font-style: italic; font-weight: bold;">New &gt; Repository
Location.<br>
<br>
</span>
<span style="font-weight: bold;"><img
 style="width: 428px; height: 260px;" alt="CVSRepositoriesView"
 src="file:///C:/Eclipse_3_1_M5a/eclipse/workspaces/dev_03_09/org.eclipse.ve.example.customwidget/WebContent/images/index.51.jpg"><br>
<br>
Figure 1 </span>The CVS Repositories view showing the correct
repository for the tutorial's finished pugin<br>
<br>
Having attached to the repository expand the <span
 style="font-style: italic;">Head </span>tree item and search for the
plugin <span style="font-style: italic;">org.eclipse.ve.examples.&nbsp;
</span>Expand this and select <span style="font-style: italic;">org.eclipse.ve.example.customwidget.</span>&nbsp;
This is the complete plugin and to install it onto your workbench use
the pop-up menu option <span style="font-weight: bold;">Check Out</span>
as shown in Figure 2<br>
<p class="PictureParagraph">
<img border="0"
 src="file:///C:/Eclipse_3_1_M5a/eclipse/workspaces/dev_03_09/org.eclipse.ve.example.customwidget/WebContent/images/index.52.jpg"></p>
<p><span style="font-weight: bold;">Figure 2 </span>Check Out <span
 style="font-style: italic;">org.eclipse.ve.example.customwidget </span>to
install the completed example into your Eclipse workbench<br>
&nbsp;</p>
<h2><a name="Conclusion">Conclusion</a></h2>
<p>In part 1 of this tutorial, we looked at a high level where to start
and extend the Visual Editor and use specialized property cell editors,
BeanInfo, GEF edit parts, palette, and CodeGen decoders.&nbsp;&nbsp;
</p>
<p>&nbsp;</p>
<p><br>
</p>
<p><small>IBM is trademark of International Business Machines
Corporation in the
United States, other countries, or both.</small></p>
<p><small>Java and all Java-based trademarks and logos are trademarks
or
registered trademarks of Sun Microsystems, Inc. in the United States,
other
countries, or both.</small></p>
<p><small>Microsoft and Windows are trademarks of Microsoft Corporation
in the
United States, other countries, or both.</small></p>
<p><small>Other company, product, and service names may be trademarks
or service
marks of others.</small></p>
</body>
</html>
